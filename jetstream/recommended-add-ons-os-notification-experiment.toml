[experiment]
analysis_unit = "client_id"

enrollment_query = """
SELECT * FROM
(

-- Early data shows that the 'experiments' annotation is more robust than either
-- the 'enrollment' or the 'exposure' event in background update telemetry, see
-- [Bug 1809275](https://bugzilla.mozilla.org/show_bug.cgi?id=1809275).  That
-- is, some legacy client IDs do not report 'enrollment' or 'exposure' events,
-- but do appear in `experiments` annotations.  Therefore, we use 'enrollment'
-- events as our primary enrollment indicator but also look for an 'experiments'
-- annotation.
--
-- But, some legacy client IDs that click the notification do not correspond to
-- default profile IDs reported by background update pings: these may be due to
-- multiple profiles, multiple OS-level users, or telemetry errors.  Some amount
-- of such client IDs are anticipated.  We use a browsing telemetry query for
-- these legacy client IDs.
--
-- Finally, we take the earliest of these two enrollment signals to determine
-- enrollment date. This will always be before we witness a notification click,
-- so we should not have a legacy client ID that does not have at least one
-- analysis window containing a notification click.

(
SELECT
    JSON_VALUE(metrics, '$.uuid.background_update_client_id') AS analysis_id,
    JSON_VALUE(event_extra, '$.branch') AS branch,
    MIN(DATE(events.submission_timestamp)) AS enrollment_date,
    COUNT(events.submission_timestamp) AS num_enrollment_events
-- Query from events_stream because it's much more efficient than unnesting events.
FROM `moz-fx-data-shared-prod.firefox_desktop_background_update.events_stream` events
WHERE
    DATE(submission_timestamp) BETWEEN
        '{{experiment.start_date_str}}' AND
        -- Here we can restrict to the last enrollment date range.
        '{{experiment.last_enrollment_date_str}}'
    AND event_category = 'nimbus_events'
    AND event_name = 'enrollment'
    -- The background update experiment slug is exact.
    AND JSON_VALUE(event_extra, '$.experiment') = '{{experiment.normandy_slug}}'
    -- This should never happen, but belt-and-braces.
    AND JSON_VALUE(metrics, '$.uuid.background_update_client_id') IS NOT NULL
    AND sample_id < 100
GROUP BY analysis_id, branch
)

UNION ALL

(
SELECT
    m.metrics.uuid.background_update_client_id AS analysis_id,
    experiment.value.branch AS branch,
    MIN(DATE(submission_timestamp)) AS enrollment_date,
    -- These aren't discrete events, it makes no sense to count them.
    1 AS num_enrollment_events
-- We need to query from the Glean `background_update` table because pre-[Bug
-- 1794053](https://bugzilla.mozilla.org/show_bug.cgi?id=1794053) (scheduled for
-- Firefox 109) we don't have the legacy client ID in
-- `mozdata.firefox_desktop_background_update.events`.
FROM `mozdata.firefox_desktop_background_update.background_update` AS m
CROSS JOIN
    UNNEST(ping_info.experiments) AS experiment
WHERE
    -- Background update telemetry can be delayed, so we accept enrollment
    -- _submission_ dates during the elongated enrollment period.  It's safer to
    -- compare submission dates generated server-side than internal ping dates
    -- generated client-side.
    DATE(submission_timestamp) BETWEEN
        '{{experiment.start_date_str}}' AND
        '{{experiment.last_enrollment_date_str}}'
    -- The background update experiment slug is exact.
    AND experiment.key = '{{experiment.normandy_slug}}'
    AND sample_id < 100
GROUP BY analysis_id, branch
)

UNION ALL

(
SELECT
    client_id AS analysis_id,
    -- Post [Bug 1804988](https://bugzilla.mozilla.org/show_bug.cgi?id=1804988),
    -- this name looks like 'slug:branch'.
    SPLIT(mozfun.map.get_key(event_map_values, 'name'), ':')[SAFE_OFFSET(1)] AS branch,
    MIN(submission_date) AS enrollment_date,
    COUNT(submission_date) AS num_enrollment_events
FROM
    `mozdata.telemetry.events`
WHERE
    -- Browsing telemetry should not be delayed, but notification clicks need
    -- not coincide with actual enrollment.
    submission_date BETWEEN
        '{{experiment.start_date_str}}' AND
        '{{experiment.last_enrollment_date_str}}'
    AND event_category = 'browser.launched_to_handle'
    AND event_method = 'system_notification'
    AND event_object = 'toast'
    -- Post [Bug 1804988](https://bugzilla.mozilla.org/show_bug.cgi?id=1804988),
    -- this name looks like 'slug:branch'.
    AND STARTS_WITH(mozfun.map.get_key(event_map_values, 'name'), '{{experiment.normandy_slug}}:')
    AND sample_id < 100
GROUP BY
    analysis_id, branch
)

)
QUALIFY ROW_NUMBER() OVER (PARTITION BY analysis_id ORDER BY enrollment_date ASC) = 1
"""


# segment information: https://docs.telemetry.mozilla.org/concepts/segments.html
segments = [
  "new_or_resurrected_v3",
  "activity_infrequent_or_casual",
  "new_unique_profiles",

  "last_dau_28_to_59_days_ago",
  "last_dau_60_to_119_days_ago",
  "last_dau_120_to_179_days_ago",
  "last_dau_180plus_days_ago",
]

[metrics]

weekly = [
  "is_default_browser",
  "number_of_desktop_launches",
  "number_of_taskbar_launches",
  "number_of_startmenu_launches",
  "number_of_taskbartab_launches",
  "ubo_newly_enabled",
  "at_least_one_add_on_installed",
  "at_least_two_add_ons_installed",
  "searches_with_serp_ad_blocker",
  "searches_with_non_serp_ad_blocker",
  "searches_with_no_ad_blocker",
]

overall = [
  "is_default_browser",
  "number_of_desktop_launches",
  "number_of_taskbar_launches",
  "number_of_startmenu_launches",
  "number_of_taskbartab_launches",
  "ubo_newly_enabled",
  "at_least_one_add_on_installed",
  "at_least_two_add_ons_installed",
  "searches_with_serp_ad_blocker",
  "searches_with_non_serp_ad_blocker",
  "searches_with_no_ad_blocker",
]

[metrics.number_of_desktop_launches.statistics.bootstrap_mean]
[metrics.number_of_taskbar_launches.statistics.bootstrap_mean]
[metrics.number_of_startmenu_launches.statistics.bootstrap_mean]
[metrics.number_of_taskbartab_launches.statistics.bootstrap_mean]
[metrics.ubo_newly_enabled.statistics.binomial]
[metrics.at_least_one_add_on_installed.statistics.binomial]
[metrics.at_least_two_add_ons_installed.statistics.binomial]
[metrics.searches_with_serp_ad_blocker.statistics.bootstrap_mean]
[metrics.searches_with_non_serp_ad_blocker.statistics.bootstrap_mean]
[metrics.searches_with_no_ad_blocker.statistics.bootstrap_mean]

[metrics.ubo_newly_enabled]
friendly_name = "uBO newly enabled"
description = "uBO not enabled on enrollment-1, and enabled at least once after enrollment"
select_expression = """
  LOGICAL_OR(
    addon_id = 'uBlock0@raymondhill.net'
    AND NOT user_disabled
    AND NOT app_disabled
    AND submission_date >= e.enrollment_date
  )
  AND
  NOT LOGICAL_OR(
    addon_id = 'uBlock0@raymondhill.net'
    AND NOT user_disabled
    AND NOT app_disabled
    AND submission_date = DATE_SUB(e.enrollment_date, INTERVAL 1 DAY)
  )
"""
data_source = "clients_daily_active_addons"
window_start = -1

[metrics.at_least_one_add_on_installed]
friendly_name = "At least one add-on installed"
description = "Maximum enabled add-on count after enrollment exceeds enabled add-on count before enrollment by at least 1"
select_expression = """
  (
    COALESCE(
      MAX(
        IF(
          submission_date >= e.enrollment_date,
          COUNTIF(NOT user_disabled AND NOT app_disabled)
            OVER (PARTITION BY submission_date),
          NULL
        )
      ),
      0
    )
    -
    COUNTIF(
      submission_date = DATE_SUB(e.enrollment_date, INTERVAL 1 DAY)
      AND NOT user_disabled
      AND NOT app_disabled
    )
  ) >= 1
"""
data_source = "clients_daily_active_addons"
window_start = -1

[metrics.at_least_two_add_ons_installed]
friendly_name = "At least two add-ons installed"
description = "Maximum enabled add-on count after enrollment exceeds enabled add-on count before enrollment by at least 2"
select_expression = """
  (
    COALESCE(
      MAX(
        IF(
          submission_date >= e.enrollment_date,
          COUNTIF(NOT user_disabled AND NOT app_disabled)
            OVER (PARTITION BY submission_date),
          NULL
        )
      ),
      0
    )
    -
    COUNTIF(
      submission_date = DATE_SUB(e.enrollment_date, INTERVAL 1 DAY)
      AND NOT user_disabled
      AND NOT app_disabled
    )
  ) >= 2
"""
data_source = "clients_daily_active_addons"
window_start = -1

[data_sources.clients_daily_active_addons]
from_expression = """(
  SELECT
    submission_date,
    client_id,
    profile_group_id,
    a.addon_id AS addon_id,
    a.user_disabled AS user_disabled,
    a.app_disabled AS app_disabled,
    is_default_browser,
    experiments
  FROM `mozdata.telemetry.clients_daily`,
  UNNEST(active_addons) AS a
)"""
friendly_name = "clients_daily active_addons unnested"
description = "One row per (client_id, submission_date, addon) from clients_daily.active_addons"

[metrics.searches_with_serp_ad_blocker]
friendly_name = "Searches with SERP ad blocker"
description = "Sum of searches (sap) on days where a SERP ad blocker is enabled"
select_expression = "SUM( IF(has_serp_ad_blocker, COALESCE(sap, 0), 0))"
data_source = "searches_with_ad_blocker_flags"

[metrics.searches_with_non_serp_ad_blocker]
friendly_name = "Searches with non-SERP ad blocker"
description = "Sum of searches (sap) on days where a non-SERP ad blocker is enabled and no SERP ad blocker is enabled"
select_expression = "SUM( IF(NOT has_serp_ad_blocker AND has_non_serp_ad_blocker, COALESCE(sap, 0), 0))"
data_source = "searches_with_ad_blocker_flags"

[metrics.searches_with_no_ad_blocker]
friendly_name = "Searches with no ad blocker"
description = "Sum of searches (sap) on days where no ad blockers are enabled"
select_expression = "SUM( IF(NOT has_serp_ad_blocker AND NOT has_non_serp_ad_blocker, COALESCE(sap, 0), 0))"
data_source = "searches_with_ad_blocker_flags"

[data_sources.searches_with_ad_blocker_flags]
from_expression = """(
  WITH addons_daily AS (
    SELECT
      submission_date,
      client_id,
      LOGICAL_OR(
        addon_id IN (
          'uBlock0@raymondhill.net',                 /* uBlock Origin */ 
          'adblockultimate@adblockultimate.net',     /* AdBlocker Ultimate */
          'firefox@ghostery.com'                     /* Ghostery */
        )
        AND NOT user_disabled
        AND NOT app_disabled
      ) AS has_serp_ad_blocker,
      LOGICAL_OR(
        addon_id IN (
          '{{d10d0bf8-f5b5-c8b4-a8b2-2b9879e08c5d}}', /* Adblock Plus */
          'jid1-NIfFY2CA8fy1tg@jetpack'               /* Adblock */
        )
        AND NOT user_disabled
        AND NOT app_disabled
      ) AS has_non_serp_ad_blocker
    FROM `mozdata.telemetry.addons`
    WHERE submission_date >= '2025-12-10'
    GROUP BY 1, 2
  )
  SELECT
    scd.submission_date,
    scd.client_id,
    scd.profile_group_id,
    scd.sap,
    COALESCE(a.has_serp_ad_blocker, FALSE) AS has_serp_ad_blocker,
    COALESCE(a.has_non_serp_ad_blocker, FALSE) AS has_non_serp_ad_blocker
  FROM `mozdata.search.search_clients_engines_sources_daily` AS scd
  LEFT JOIN addons_daily AS a
    USING (submission_date, client_id)
  WHERE scd.submission_date >= '2025-12-10'
)"""
friendly_name = "Searches joined to ad blocker flags"
description = "Daily SAP joined to daily addon-derived ad blocker flags"

# ============================================================================
# USER SEGMENTS - Based on activity patterns before enrollment
# ============================================================================
# Using e.enrollment_date to reference enrollment date
# (see https://github.com/mozilla/mozanalysis/blob/ccabadcc5233a1f48f528fa4a23e3495b3ac9ea2/src/mozanalysis/segments.py#L132-L156)
# Using a 1 year week lookback window (365 days)

[segments.last_dau_28_to_59_days_ago]
friendly_name = "Last DAU 28 to 59 days ago"
description = "Clients who last counted towards DAU 28–59 days before enrollment"
select_expression = "DATE_DIFF(MAX(e.enrollment_date), MAX(submission_date), DAY) BETWEEN 28 AND 59"
data_source = "active_users_last_seen"
window_start = -365
window_end = -1

[segments.last_dau_60_to_119_days_ago]
friendly_name = "Last DAU 60 to 119 days ago"
description = "Clients who last counted towards DAU 60–119 days before enrollment"
select_expression = "DATE_DIFF(MAX(e.enrollment_date), MAX(submission_date), DAY) BETWEEN 60 AND 119"
data_source = "active_users_last_seen"
window_start = -365
window_end = -1

[segments.last_dau_120_to_179_days_ago]
friendly_name = "Last DAU 120 to 179 days ago"
description = "Clients who last counted towards DAU 120–179 days before enrollment"
select_expression = "DATE_DIFF(MAX(e.enrollment_date), MAX(submission_date), DAY) BETWEEN 120 AND 179"
data_source = "active_users_last_seen"
window_start = -365
window_end = -1

[segments.last_dau_180plus_days_ago]
friendly_name = "Last DAU 180+ days ago"
description = """
Clients whose last DAU before enrollment is >=180 days ago (or no DAU observed in lookback window), excluding new users.
No DAU in lookback window generally means the profile was last seen before the first date in the lookback window.
"""
select_expression = """
  (
    MAX(submission_date) IS NULL
    OR DATE_DIFF(MAX(e.enrollment_date), MAX(submission_date), DAY) >= 180
  )
  AND COALESCE(MAX(is_new_user), FALSE) = FALSE
"""
data_source = "active_users_last_seen"
window_start = -365
window_end = -1

[segments.data_sources.active_users_last_seen]
from_expression = """(
  SELECT
    client_id,
    profile_group_id,
    submission_date,
    first_seen_date >= '2025-12-10' AS is_new_user
  FROM `mozdata.telemetry.desktop_active_users`
  WHERE is_desktop
    AND is_dau
    AND submission_date >= DATE_SUB('2025-12-10', INTERVAL 365 DAY)
)"""
window_start = -365
